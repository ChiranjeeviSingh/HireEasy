
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>handlers: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">backend/internal/api/handlers/auth.go (0.0%)</option>
				
				<option value="file1">backend/internal/api/handlers/job_submission.go (75.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package handlers

import (
    "net/http"
    "github.com/gin-gonic/gin"
    "backend/internal/services"
)


func Login(ctx *gin.Context) <span class="cov0" title="0">{
    var loginReq services.LoginRequest

    if err := ctx.ShouldBindJSON(&amp;loginReq); err != nil </span><span class="cov0" title="0">{
        ctx.JSON(http.StatusBadRequest, gin.H{"msg": "Invalid input", "error": err.Error()})
        return
    }</span>

    <span class="cov0" title="0">token, err := services.Login(ctx, &amp;loginReq)
    if err != nil </span><span class="cov0" title="0">{
        ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized", "error": err.Error()})
        return
    }</span>

    <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{"token": token})</span>
}


func Register(ctx *gin.Context) <span class="cov0" title="0">{
    var registerReq services.RegisterRequest
    if err := ctx.ShouldBindJSON(&amp;registerReq); err != nil </span><span class="cov0" title="0">{
        ctx.JSON(http.StatusBadRequest, gin.H{"msg": "Invalid input", "error": err.Error()})
        return
    }</span>

    <span class="cov0" title="0">authResponse, err := services.Register(ctx, &amp;registerReq)
    if err != nil </span><span class="cov0" title="0">{
        if err == services.ErrEmailExists </span><span class="cov0" title="0">{
            ctx.JSON(http.StatusBadRequest, gin.H{"msg": "Bad request", "error": err.Error()})
            return
        }</span>
        <span class="cov0" title="0">ctx.JSON(http.StatusInternalServerError, gin.H{"msg": "Could not create user", "error": err.Error()})
        return</span>
    }

    <span class="cov0" title="0">ctx.JSON(http.StatusCreated, authResponse)</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">package handlers

import (
        "backend/internal/database"
        "backend/internal/models"
        "backend/internal/services"
        "encoding/json"
        "log"
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/lib/pq"
)

// HandleFormSubmission processes a form submission
func HandleFormSubmission(c *gin.Context) <span class="cov8" title="1">{
        var submission models.FormSubmissionRequest
        // Bind form data
        // Print all form values for debugging
        formValues, _ := c.MultipartForm()
        log.Println("üîç Raw Form Data Received:", formValues.Value)

        // Bind the form data
        if err := c.ShouldBind(&amp;submission); err != nil </span><span class="cov8" title="1">{
                log.Println("Error Binding Form:", err)
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid submission data", "details": err.Error()})
                return
        }</span>

        // Debugging: Print extracted UserID
        <span class="cov8" title="1">log.Println("Extracted UserID:", submission.UserID)

        formUUIDStr := c.Param("form_uuid")
        formUUID, err := uuid.Parse(formUUIDStr)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid form_uuid"})
                return
        }</span>

        // Get database instance
        <span class="cov8" title="1">db := database.GetDB()

        // Insert user if they don't exist
        log.Println("üîç Checking if user exists:", submission.UserID)
        // Check if user exists
        // Ensure UserID is valid before inserting
        log.Println(submission.UserID)
        if submission.UserID &lt;= 0 </span><span class="cov0" title="0">{
                log.Println("Invalid UserID:", submission.UserID)
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid User ID"})
                return
        }</span>

        // Check if user exists
        <span class="cov8" title="1">var userExists bool
        err = db.QueryRow("SELECT EXISTS(SELECT 1 FROM users WHERE id = $1)", submission.UserID).Scan(&amp;userExists)
        log.Println("üîç Checking if user exists:", submission.UserID, "Exists?", userExists, "Error:", err)

        if err != nil </span><span class="cov0" title="0">{
                log.Println("Error checking user existence:", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Database error while checking user"})
                return
        }</span>

        // Insert user if they don't exist
        <span class="cov8" title="1">if !userExists </span><span class="cov8" title="1">{
                log.Println("üÜï Creating new user:", submission.UserID)

                // Generate a placeholder password hash (since it's required)
                dummyPassword := "$2a$10$defaultdefaultdefaultdefaultdefaultdefault"

                query := `
        INSERT INTO users (id, username, email, password_hash, created_at, updated_at)
        VALUES ($1, $2, $3, $4, NOW(), NOW())`

                log.Println("üõ† Executing INSERT query:", query)
                log.Println("‚û°Ô∏è With values:", submission.UserID, submission.Username, submission.Email, dummyPassword)

                _, err = db.Exec(query, submission.UserID, submission.Username, submission.Email, dummyPassword)

                if err != nil </span><span class="cov0" title="0">{
                        log.Println("Failed to insert new user:", err)
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create new user", "details": err.Error()})
                        return
                }</span>

                <span class="cov8" title="1">log.Println("User inserted successfully:", submission.UserID)</span>
        }

        // Verify User Insertion
        <span class="cov8" title="1">var verifiedUserCount int
        err = db.QueryRow("SELECT COUNT(*) FROM users WHERE id = $1", submission.UserID).Scan(&amp;verifiedUserCount)
        log.Println("üîç Verified user count:", verifiedUserCount, "Error:", err)

        if err != nil || verifiedUserCount == 0 </span><span class="cov0" title="0">{
                log.Println("User was NOT inserted successfully. Aborting submission.")
                c.JSON(http.StatusInternalServerError, gin.H{"error": "User insertion failed, cannot submit job application"})
                return
        }</span>

        <span class="cov8" title="1">log.Println("User exists and is verified in `users` table:", submission.UserID)

        // Check if user already applied for this job
        var alreadyApplied bool
        err = db.QueryRow("SELECT EXISTS(SELECT 1 FROM job_submissions WHERE user_id = $1 AND job_id = $2)", submission.UserID, submission.JobID).Scan(&amp;alreadyApplied)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Error checking previous applications:", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Database error"})
                return
        }</span>
        <span class="cov8" title="1">if alreadyApplied </span><span class="cov8" title="1">{
                log.Println("‚ö†Ô∏è User already applied for this job:", submission.UserID)
                c.JSON(http.StatusBadRequest, gin.H{"error": "User has already applied for this job"})
                return
        }</span>

        // Parse `form_data`
        <span class="cov8" title="1">var formData map[string]interface{}
        err = json.Unmarshal([]byte(submission.FormData), &amp;formData)
        if err != nil </span><span class="cov8" title="1">{
                log.Println("JSON Parse Error:", err)
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid form data format"})
                return
        }</span>

        // Extract `skills`
        <span class="cov8" title="1">var extractedSkills []string
        if rawSkills, exists := formData["skills"]; exists </span><span class="cov8" title="1">{
                skillsArray, ok := rawSkills.([]interface{})
                if ok </span><span class="cov8" title="1">{
                        for _, skill := range skillsArray </span><span class="cov8" title="1">{
                                if skillStr, ok := skill.(string); ok </span><span class="cov8" title="1">{
                                        extractedSkills = append(extractedSkills, skillStr)
                                }</span>
                        }
                }
        }

        // Fetch required skills from job template
        <span class="cov8" title="1">var requiredSkills []string
        err = db.Select(&amp;requiredSkills, "SELECT skills_required FROM jobs WHERE job_id = $1", submission.JobID)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Error fetching job required skills:", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Job required skills not found"})
                return
        }</span>

        // Compute ATS Score
        <span class="cov8" title="1">atsScore := services.MockATSScore(extractedSkills, requiredSkills)

        // Upload resume
        resumeURL, err := uploadResumeFunc(submission.Resume, submission.UserID, submission.Username)
        if err != nil </span><span class="cov8" title="1">{
                log.Println("Resume Upload Error:", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to upload resume"})
                return
        }</span>

        // Store submission in DB
        <span class="cov8" title="1">formDataJSON, _ := json.Marshal(formData)
        query := `
                INSERT INTO job_submissions (form_uuid, job_id, user_id, form_data, skills, resume_url, ats_score) 
                VALUES ($1, $2, $3, $4, $5, $6, $7)
        `

        _, err = db.Exec(query, formUUID, submission.JobID, submission.UserID, formDataJSON, pq.Array(extractedSkills), resumeURL, atsScore)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Database Insert Error:", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "Failed to store form submission",
                        "details": err.Error(),
                })
                return
        }</span>

        // Success response
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "message":   "Submission received successfully",
                "ats_score": atsScore,
        })</span>
}

func GetFormSubmissions(c *gin.Context) <span class="cov8" title="1">{
        formUUID := c.Param("form_uuid")

        // Validate UUID format
        _, err := uuid.Parse(formUUID)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Invalid form_uuid format:", err)
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid form_uuid"})
                return
        }</span>

        <span class="cov8" title="1">db := database.GetDB()

        // Check if form UUID exists in `form_templates` before fetching submissions
        var count int
        err = db.Get(&amp;count, "SELECT COUNT(*) FROM form_templates WHERE id = $1", formUUID)
        if err != nil || count == 0 </span><span class="cov8" title="1">{
                log.Println("Form UUID not found in form_templates")
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid form_uuid, form does not exist"})
                return
        }</span>

        // Proceed with fetching submissions if form exists
        <span class="cov8" title="1">sortBy := c.DefaultQuery("sort_by", "ats_score")
        limitStr := c.DefaultQuery("limit", "20")

        limit, err := strconv.Atoi(limitStr)
        if err != nil || limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 20
        }</span>

        <span class="cov8" title="1">var submissions []models.JobSubmission
        query := `SELECT id, job_id, user_id, form_uuid, form_data, skills, resume_url, ats_score, created_at
        FROM job_submissions 
        WHERE form_uuid = $1 
        ORDER BY ` + sortBy + ` DESC 
        LIMIT $2`

        err = db.Select(&amp;submissions, query, formUUID, limit)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Database Query Error:", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch submissions"})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"submissions": submissions})</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
